
(This code is contributed by Riyazul555)


Time Complexity = O(2^N)
Space Complexity = O(N + M)

PSEUDOCODE

function BFS(nod, G, viz) {
    Q = Queue()
    viz[nod] <- True
    Q.push((0, nod))
    while not Q.empty() {
        _, nod = Q.front()
        Q.pop()
        for i in G[nod] {
            if not viz[i] {
                viz[i] <- True
                Q.push((0, i))
            }
        }
    }
}

function isConnected(n, m, G, vert) {
    viz = array of size nMax initialized to False
    BFS(vert[0], G, viz)
    for i in vert {
        if not viz[i] {
            return False
        }
    }
    return True
}

function isComplete(n, G, vert) {
    for i in vert {
        if size of G[i] != n - 1 {
            return False
        }
    }
    return True
}

function chromaticPolynomial(k, n, m, G, vert) {
    if m == 0 {
        p = 1
        for i from 1 to n {
            p = (p % MOD * k % MOD) % MOD
        }
        return p
    }
    if isComplete(n, G, vert) {
        p = 1
        for i from k - n + 1 to k {
            p = (p % MOD * i % MOD) % MOD
        }
        return p
    }
    if isConnected(n, m, G, vert) and m == n - 1 {
        p = k % MOD
        for i from 1 to n - 1 {
            p = (p % MOD * (k - 1) % MOD) % MOD
        }
        return p
    }
    G1 = array of lists of integers of size nMax
    ind = 0
    while size of G[vert[ind]] == 0 {
        ind++
    }
    p1 = vert[ind]
    p2 = G[p1].back()
    for i in vert {
        for j in G[i] {
            if (i == p1 and j == p2) or (i == p2 and j == p1) {
                continue
            }
            G1[i].push_back(j)
        }
    }
    vert2 = array of integers
    for i in vert {
        if i != p2 {
            vert2.push_back(i)
        }
    }
    G2 = array of lists of integers of size nMax
    for i in vert2 {
        for j in G1[i] {
            if j == p2 {
                if p1 not in G2[i] {
                    G2[i].push_back(p1)
                }
            } else {
                if j not in G2[i] {
                    G2[i].push_back(j)
                }
            }
        }
        if i == p1 {
            for j in G1[p2] {
                if j not in G2[i] {
                    G2[i].push_back(j)
                }
            }
        }
    }
    sz = 0
    for i in vert2 {
        sz += size of G2[i]
    }
    sz //= 2
    return (chromaticPolynomial(k, n, m - 1, G1, vert) % MOD - chromaticPolynomial(k, n - 1, sz, G2, vert2) % MOD + MOD) % MOD
}

function chromaticNumber(n, m, G, vert) {
    for i from 1 to n {
        if chromaticPolynomial(i, n, m, G, vert) != 0 {
            return i
        }
    }
    return -1
}

function main() {
    n, m = read from input file
    G = array of lists of integers of size nMax
    for i from 1 to m {
        x, y = read from input file
        G[x].push_back(y)
        G[y].push_back(x)
    }
    vert = array of integers
    for i from 0 to n - 1 {
        vert.push_back(i)
    }
    k = chromaticNumber(n, m, G, vert)
    write k to output file
    st = array of integers of size nMax
    gr = array of integers of size nMax
    for i from 0 to n - 1 {
        gr[i] = size of G[i]
    }
    while len(st) < n {
        cnt = 0
        for i from 0 to n - 1 {
            if gr[i] > -1 and gr[i] < k {
                gr[i] = -1
                st.append(i)
                for j in G[i] {
                    gr[j] -= 1
                }
                cnt += 1
            }
        }
        if cnt == 0 {
            pos = 0
            while gr[pos] == -1 and pos < n - 1 {
                pos++
            }
            gr[pos] = -1
            st.append(pos)
            for j in G[pos] {
                gr[j] -= 1
            }
        }
    }
    col = array of integers of size nMax
    fill col with -1
    for i from len(st) - 1 to 0 step -1 {
        ap = array of booleans of size k initialized to False
        for j in G[st[i]] {
            if col[j] != -1 {
                ap[col[j]] = True
            }
        }
        ncol = 0
        while ap[ncol] and ncol < k {
            ncol++
        }
        if ncol < k {
            col[st[i]] = ncol
        }
    }
    for i from 0 to n - 1 {
        write col[i] to output file
    }
}
